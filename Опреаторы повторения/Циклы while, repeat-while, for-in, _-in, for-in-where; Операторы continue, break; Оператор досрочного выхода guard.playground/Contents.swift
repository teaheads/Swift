// While - пока
// While - цикл с предварительной проверкой условия
// Данный цикл будет выплняться до тех пор, пока условие будет true

/*
 // Данный цикл будет выполняться бесконечно
while true {
    print("Infiniti loop")
}
*/

// Одно выполнение кода в теле оператора называется итерацией
// Итерация продолжается, пока выражение возвращает true
// Перед началом выполнения итерации while проверяет условие, только после этого выполняет код в теле оператора

var valueInWhile = 1

while 1...5 ~= valueInWhile {
    valueInWhile += 1
}

/// Вход
// Проверка условия: 1 входит в диапазон, 1...5 ~= valueInWhile = true
// Итерация №1: Выполняется код в теле оператора: 1 = 1 + 1, valueInWhile = 2

/// Переход в начало

// Проверка условия: 2 входит в диапазон, 1...5 ~= valueInWhile = true
// Итерация №2: Выполняется код в теле оператора: 2 = 2 + 1, valueInWhile = 3

/// Переход в начало

// Проверка условия: 3 входит в диапазон, 1...5 ~= valueInWhile = true
// Итерация №3: Выполняется код в теле оператора: 3 = 3 + 1, valueInWhile = 4

/// Переход в начало

// Проверка условия: 4 входит в диапазон, 1...5 ~= valueInWhile = true
// Итерация №4: Выполняется код в теле оператора: 4 = 4 + 1, valueInWhile = 5

/// Переход в начало

// Проверка условия: 5 входит в диапазон, 1...5 ~= valueInWhile = true
// Итерация №5: Выполняется код в теле оператора: 5 = 5 + 1, valueInWhile = 6

/// Переход в начало

// Проверка условия: 6 не входит в диапазон, 1...5 ~= valueInWhile = false
/// Выход


// Практика, while

var value = 2

while 1..<10 ~= value {
    value += 2
}

value = 20

while 0...20 ~= value {
    value -= 1
}

var i = 1
var resultSum = 0

while i <= 10 {
    resultSum += i
    i += 1
}

i = 1

while 0...10 ~= i {
    i *= 2
}
i



// Оператор continue - продолжить
// continue предназначен для перехода в начало цикла
// Если в теле инструкции if используется оператор continue, то как только проверяемое условие if становится true, и ход выполнения программы попадает в continue, то происходит переход в самое начало цикла, т.е ход выполнения программы переходит в проверяемое условие.

var x = 0
var sum = 0

while x <= 5 {
    x += 1
    if x % 2 == 1 {
        continue
    }
    sum += x
}

/// Вход
// Проверка условия while: x <= 5 (0 <= 5) = true
// Итерация № 1: Выполняется код в теле while:
// x += 1 (0 += 1)
// x = 1

// Проверка условия if: x % 2 == 1 = true
// {Выполняется код в теле инструкции if}
// continue

/// Переход в начало

// Проверка условия while: x <= 5 (1 <= 5) = true
// Итерация № 2: Выполняется код в теле while:
// x += 1 (1 += 1)
// x = 2

// Проверка условия if: x % 2 == 1 = false

// Итерация № 3: Выполняется следующий код теле while:
// sum += x (0 += 2)
// sum = 2

/// Переход в начало

// Проверка условия while: x <= 5 (2 <= 5) = true
// Итерация № 4: Выполняется код в теле while:
// x += 1 (2 += 1)
// x = 3

// Проверка условия if: x % 2 == 1 = true
// continue

/// Переход в начало

// Проверка условия while: x <= 5 = true
// Итерация № 5: Выполняется код в теле while:
// x += 1 (3 += 1)
// x = 4

// Проверка условия if: x % 2 == 1 = false

// Итерация № 6: Выполняется следующий код теле while:
// sum += x (2 += 4)
// sum = 6

/// Переход в начало

// Проверка условия while: x <= 5 = true
// Итерация № 7: Выполняется код в теле while:
// x += 1 (4 += 1)
// x = 5

// Проверка условия if: x % 2 == 1 = true
// continue

/// Переход в начало

// Проверка условия while: x <= 5 = true
// Итерация № 8: Выполняется код в теле while:
// x += 1 (5 += 1)
// x = 6

// Проверка условия if: x % 2 == 1 = false

// Итерация № 9: Выполняется следующий код теле while:
// sum += x (6 += 6)
// sum = 12

/// Переход в начало

// Проверка условия while: x <= 5 = false
/// Выход



var a = 0

// 10 итераций
while a < 5 {
    a += 1
    if a % 2 == 0 {
        print("Четное число")
        continue
}
    print("Нечетное число")
}

print("-----------------")

a = 1

// 10 итераций
while 1...5 ~= a {
    a += 1
    if a % 2 == 1 {
        print("Нечетное число")
        continue
    }
    print("Четное число")
}


value = 0
sum = 0

while value <= 5 {
    value += 1
    if value % 2 == 0 {
        continue
    }
    sum += value
}

// Опрератор break - прервать
// Оператор break предназначен для досрочного завершения работы цикла.
// Если в теле инструкции if используется оператор break, то как только проверяемое условие if становится true, и ход выполнения программы попадает в break то происходит полное завершение работы цикла.

var countDown = 10
while countDown >= 0 {
    print(countDown)
    
    if countDown == 4 {
        print("Go now")
        break
    }
    countDown -= 1
}

/// Вход в цикл
// Проверка условия while: countDown >= 0 = true
// Итерация № 1: выполняется код в теле while:
// print(countDown) ; 10

// Проверка условия if: 10 == 4 = false

// Итерация № 2: выполняется следующий код в теле while:
// countDown -= 1 ; countDown = 9

/// Переход в начало

// Проверка условия while: countDown >= 0 = true
// Итерация № 3: выполняется код в теле while:
// print(countDown) ; 9

// Проверка условия if: 9 == 4 = false

// Итерация № 4: выполняется следующий код в теле while:
// countDown -= 1 ; countDown = 8

/// Переход в начало

// Проверка условия while: countDown >= 0 = true
// Итерация № 5: выполняется код в теле while:
// print(countDown) ; 8

// Проверка условия if: 8 == 4 = false

// Итерация № 6: выполняется следующий код в теле while:
// countDown -= 1 ; countDown = 7

/// Переход в начало

// Проверка условия while: countDown >= 0 = true
// Итерация № 7: выполняется код в теле while:
// print(countDown) ; 7

// Проверка условия if: 7 == 4 = false

// Итерация № 8: выполняется следующий код в теле while:
// countDown -= 1 ; countDown = 6

/// Переход в начало

// Проверка условия while: countDown >= 0 = true
// Итерация № 9: выполняется код в теле while:
// print(countDown) ; 6

// Проверка условия if: 6 == 4 = false

// Итерация № 10: выполняется следующий код в теле while:
// countDown -= 1 ; countDown = 5

/// Переход в начало

// Проверка условия: countDown >= 0 = true
// Итерация № 11: выполняется код в теле while:
// print(countDown) ; 5

// Проверка условия if: 5 == 4 = false

// Итерация № 12: выполняется следующий код в теле while:
// countDown -= 1 ; countDown = 4

/// Переход в начало

// Проверка условия: countDown >= 0 = true
// Итерация № 13: выполняется код в теле while:
// print(countDown) ; 4

// Проверка условия if: 4 == 4 = true
// {Выполняется код в теле оператора if}
// print("Go now!") ; "Go now!"
// break
/// Выход из цикла

var currentNum = 1
var sumOfInts = 0

while currentNum <= 10 {
    sumOfInts += currentNum
    if sumOfInts >= 10 {
        break
    }
    currentNum += 1
}

/// Вход в цикл
// Проверка условия while: currentNum <= 10 = true
// Итерация № 1: Выполняется код в теле оператора while:
// sumOfInts += currentNum (0 += 1) ; sumofInts = 1

// Проверка условия if: sumofInts >= 10 (1 >= 10) = false

// Итерация № 2: Выполняется следующий код в теле оператора while:
// currentNum += 1 ; currentNum = 2

/// Переход в начало

// Проверка условия: currentNum <= 10 = true
// Итерация № 3: Выполняется код в теле оператора while:
// sumOfInts += currentNum (1 += 2) ; sumOfInts = 3

// Проверка условия if: sumofInts >= 10 (3 >= 10) = false

// Итерация № 4: Выполняется следующий код в теле оператора while:
// currentNum += 1 (2 += 1) ; currentNum = 3

/// Переход в начало

// Проверка условия: currentNum <= 10 = true
// Итерация №5: Выполняется код в теле оператора while:
// sumOfInts += currentNum (3 += 3) ; sumOfInts = 6

// Проверка условия if: sumofInts >= 10 (6 >= 10) = false

// Итерация № 6: Выполняется следующий код в теле оператора while:
// currentNum += 1 ; currentNum = 4

/// Переход в начало

// Проверка условия: currentNum <= 10 = true
// Итерация № 7: Выполняется код в теле оператора while:
// sumOfInts += currentNum (6 += 4) ; sumOfInts = 10

// Проверка условия if: sumofInts >= 10 = true
// {Выполняется код в телеоператора if}
// break
/// Выход из цикла



// Repeat while
// Цикл с постпроверкой условия
// Проверка значения выражения происходит после итерации
/// 1. Итерация
/// 2. Проверка условия

/*
repeat {
    
} while true
*/

var valueInRepeatWhile = 1

repeat {
    valueInRepeatWhile += 1
} while 1...5 ~= valueInRepeatWhile

/// Вход
// Итерация № 1: Выполняется код в теле оператора repeat: 1 = 1 + 1, valueInWhile = 2
// Проверка условия while: 2 входит в диапазон, 1...5 ~= valueInWhile = true

/// Переход в начало

// Итерация № 2: Выполняется код в теле оператора repeat: 2 = 2 + 1, valueInWhile = 3
// Проверка условия while: 3 входит в диапазон, 1...5 ~= valueInWhile = true

/// Переход в начало

// Итерация № 3: Выполняется код в теле оператора repeat: 3 = 3 + 1, valueInWhile = 4
// Проверка условия while: 4 входит в диапазон, 1...5 ~= valueInWhile = true

/// Переход в начало

// Итерация № 4: Выполняется код в теле оператора repeat: 4 = 4 + 1, valueInWhile = 5
// Проверка условия while: 5 входит в диапазон, 1...5 ~= valueInWhile = true

/// Переход в начало

// Итерация № 5: Выполняется код в теле оператора repeat: 5 = 5 + 1, valueInWhile = 6
// Проверка условия while: 6 не входит в диапазон, 1...5 ~= valueInWhile = false
/// Выход

i = 1
resultSum = 0

repeat {
    resultSum += i
    i += 1
} while i <= 10



// for - для, in - в

/*
for связанный_параметр in последовательность {
    тело оператора
}
*/
// связанный_параметр - локальная константа, объявляемоя после ключевого слова for, которой будет инициализировано очередное значение из перебираемой по порядку последовательности

// последовательность (то у чего есть начало и конец) - по ней происходит итерация, которая идет по порядку, от первого до последнего, эти элементы из последовательности передаются по одному в связанный_параметр

// тело оператора - код, выполняется столько раз, сколько будет выполнено итераций


for i in [1, 2, 3, 4] {
    print(i)
}

/// Вход
// Выполняется проверка: имеются ли значения в данном массиве ? = true
// Выполняется привязка первого элемента массива к связанному параметру i
// Итерация № 1: print(i)
// (консоль: 1)

/// Переход в начало

// Выполняется проверка: имеются ли ещё значения в данном массиве ? = true
// Выполняется привязка следующего элемента масссива к связанному параметру i
// Итерация № 2: print(i)
// (консоль: 2)

/// Переход в начало

// Выполняется проверка: имеются ли ещё значения в данном массиве ? = true
// Выполняется привязка следующего элемента масссива к связанному параметру i
// Итерация № 3: print(i)
// (консоль: 3)

/// Переход в начало

// Выполняется проверка: имеются ли ещё значения в данном массиве ? = true
// Выполняется привязка следующего элемента масссива к связанному параметру i
// Итерация № 4: print(i)
// (консоль: 4)

/// Переход в начало

// Выполняется проверка: имеются ли ещё значения в данном массиве ? = false
/// Выход


// Массив
let array = [1, 2, 3, 4, 5]

var sumIntInArray = 0

// Посчитаем сумму всех элементов в массиве
for number in array {
    sumIntInArray += number
}

// Посчитаем колличество значений диапазон
for number in 1...5 {
    print(number)
}

// Посчитаем колл-во букв в слове
for word in "Swift" {
    print(word)
}

// Связанный параметр и все объявленные в теле цикла переменные и константы - сугубо локальные, т.е недоступны вне оператора for.
// Если существуют внешние (что объявленные вне цикла) одноименные переменные и константы  - то их значение НЕ будет пересекаться со значением локальных переменных и констант, что объявленны внутри цикла.

var myChar = "a"
let myString = "Swift"

for myChar in myString { // myChar - связанный параметр (локальная константа) , а не переменная myChar.
    let myString = "Char is" // myString - объявленная внутри for переменная, а не внешняя myString
    print("\(myString) \(myChar)") // Выводится внутренняя переменная myString и значение связанного параметра myChar
}
myChar
myString

/// Вход
// Выполняется проверка: имеются ли строки в данной последовательности ? = true
// Выполняется привязка первого элемента последовательности к связанному локальному параметру myChar

// Итерация № 1:
// let myString = "Char is"

// Итерация № 2:
// print("\(myString) \(myChar)") // консоль: Char is S

/// Переход в начало

// Выполняется проверка: имеются ли ещё строки в данной последовательности ? = true
// Выполняется привязка следующего элемента последовательности к связанному локальному параметру myChar

// Итерация № 3:
// let myString = "Char is"

// Итерация № 4:
// print("\(myString) \(myChar)") // консоль: Char is w

/// Переход в начало

// Выполняется проверка: имеются ли ещё строки в данной последовательности ? = true
// Выполняется привязка следующего элемента последовательности к связанному локальному параметру myChar

// Итерация № 5:
// let myString = "Char is"

// Итерация № 6:
// print("\(myString) \(myChar)") // консоль: Char is i

/// Переход в начало

// Выполняется проверка: имеются ли ещё строки в данной последовательности ? = true
// Выполняется привязка следующего элемента последовательности к связанному локальному параметру myChar

// Итерация № 7:
// let myString = "Char is"

// Итерация № 8:
// print("\(myString) \(myChar)") // консоль: Char is f

/// Переход в начало

// Выполняется проверка: имеются ли ещё строки в данной последовательности ? = true
// Выполняется привязка следующего элемента последовательности к связанному локальному параметру myChar

// Итерация № 9:
// let myString = "Char is"

// Итерация № 10:
// print("\(myString) \(myChar)") // консоль: Char is t

/// Переход в начало

// Выполняется проверка: имеются ли ещё строки в данной последовательности ? = false
/// Выход


// Если нет сысла использовать связанный_параметр для передачи ему значения эелементов из перебираемой послежовательности, то для экономия памяти используется _ .

for _ in 1...3 {
    print("Просто повторяющаяся строка")
}

// При итерации по элементам словаря (Dictionary - не упорядоченная коллекция) можно создать отдельные связанный параметры для ключей и значений элементов.

var countriesAndBlocks = ["Russia": "СНГ", "France": "ЕС"]
for (countyName, orgName) in countriesAndBlocks { // countyName - key, orgName - value
    print("\(countyName) вступила в \(orgName)")
}

// Если требуется получать только ключи или только значения элементов, то можно вновь воспользоваться _ .

for (countryName, _) in countriesAndBlocks {
    print("страна - \(countryName)")
}

for (_, orgName) in countriesAndBlocks {
    print("организация - \(orgName)")
}

// Если требуется получить последовательность состоящую только из ключей или значений словаря то можно воспользоваться свойствам keys и values - и передать результат их работы в оператор for

countriesAndBlocks = ["Россия": "ЕАЭС", "Фрация": "ЕС"]

for countryName in countriesAndBlocks.keys {
    print("Страна - \(countryName)")
}

for orgName in countriesAndBlocks.values {
    print("Организация - \(orgName)")
}

// Если при работе с массивом для каждого элемента помимо значения требуется получить ещё и его индекс то можно воспользоваться методом enumirated() что возвращает последовательность кортежей, где первый элемент - индекс, второй - значение

let myMusicStyles = ["Rock", "Blues", "Metal"]

for (index, musicName) in myMusicStyles.enumerated() {
    print("\(index + 1). Я люблю \(musicName)")
}

// Вернемся к работес полледовательностями, состоящими из чисел
// Перед нами стоит задача:
// Обработать все числа от 1 до 10, идущие с шагом 3 [1, 4, 7, 10]
// В данном случае мы можем "руками" создать такую коллекцию с необходимыми элементами и передать её в конструкцию for - in

let intNumber = [1, 4, 7, 10]

for element in intNumber {
    print(element)
}

// Но если диапазон чисел будет от 1 до 1000 с шагом в 5 то сздать его "руками" будет тяжело
// Также возможна ситуация, когда начало и конец, а также шаг могут быть вовсе неизвестны
// В таких случаях нам удобнее всего воспользоваться специальными функциями: stride

/// Данныне функции формируют последовательность (Sequence) элементов на основе заданных правил:
// stride(from:through:by:) вернуть последовательность (от: , до: , с шагом: )
// stride(from:to:by) (от:до:шаг) вернуть последовательность (от: , до и исключая: , с шагом: )

/// коллекции элементов что возвращает функция представленна в виде значения специального типа данных: to strideThrough<T>, где T - это тип данных элементов коллекции
for i in stride(from: 1, through: 10, by: 3) {
    print(i)
}

/// коллекции элементов что возвращает функция представленна в виде значения специального типа данных: to strideTo<T>, где T - это тип данных элементов коллекции
for i in stride(from: 1, to: 10, by: 3) {
    print(i)
}

// Вычисление суммы всех нечетных чисел от 1 до 1000
var result = 0
for i in stride(from: 1, through: 1000, by: 2) { // 1, 3, 5, 7, 9, 11, ...
    result += i // 0 += 1, 1 += 3, 4 += 5, 9 += 7, 16 += 9, 25 += 11, ...
}
result

// Использование where в конструкции for - in
// where используется для указания дополнительного условия итерации элементов последовательности
// Код в теле оператора (итерация) будет выполняться только если условие where = true

result = 0
for i in 1...10 where i % 2 == 0 {
    result += i
}

/// Вход
// Выполняется проверка:
// Имеются ли значения в данной последовательности ? = true
// Выполняется привязка первого элемента последовательности к связанному локальному параметру i
// Выполняется проверка условия where:
// Данный элемент последовательности связанный с локальным параметром i % 2 == 0 = false

/// Переход в начало

// Имеются ли ещё значения в данной последовательности ? = true
// Выполняется привязка следующего элемента последовательности к связанному локальному параметру i
// Выполняется проверка условия where:
// Данный элемент последовательности связанный с локальным параметром i % 2 == 0 = true

// Выполняется итерация № 1:
// result += i (0 += 2) (result = 2)

/// Переход в начало

// Имеются ли ещё значения в данной последовательности ? = true
// Выполняется привязка следующего элемента последовательности к связанному локальному параметру i
// Выполняется проверка условия where:
// Данный элемент последовательности связанный с локальным параметром i % 2 == 0 = false

/// Переход в начало

// Имеются ли ещё значения в данной последовательности ? = true
// Выполняется привязка следующего элемента последовательности к связанному локальному параметру i
// Выполняется проверка условия where:
// Данный элемент последовательности связанный с локальным параметром i % 2 == 0 = true

// Выполняется итерация № 2:
// result += i (2 += 4) (result = 6)

/// Переход в начало

// Имеются ли ещё значения в данной последовательности ? = true
// Выполняется привязка следующего элемента последовательности к связанному локальному параметру i
// Выполняется проверка условия where:
// Данный элемент последовательности связанный с локальным параметром i % 2 == 0 = false

/// Переход в начало

// Имеются ли ещё значения в данной последовательности ? = true
// Выполняется привязка следующего элемента последовательности к связанному локальному параметру i
// Выполняется проверка условия where:
// Данный элемент последовательности связанный с локальным параметром i % 2 == 0 = true

// Выполняется итерация № 3:
// result += i (6 += 6) (result = 12)

/// Переход в начало

// Имеются ли ещё значения в данной последовательности ? = true
// Выполняется привязка следующего элемента последовательности к связанному локальному параметру i
// Выполняется проверка условия where:
// Данный элемент последовательности связанный с локальным параметром i % 2 == 0 = false

/// Переход в начало

// Имеются ли ещё значения в данной последовательности ? = true
// Выполняется привязка следующего элемента последовательности к связанному локальному параметру i
// Выполняется проверка условия where:
// Данный элемент последовательности связанный с локальным параметром i % 2 == 0 = true

// Выполняется итерация № 4:
// result += i (12 += 8) (result = 20)

/// Переход в начало

// Имеются ли ещё значения в данной последовательности ? = true
// Выполняется привязка следующего элемента последовательности к связанному локальному параметру i
// Выполняется проверка условия where:
// Данный элемент последовательности связанный с локальным параметром i % 2 == 0 = false

/// Переход в начало

// Имеются ли ещё значения в данной последовательности ? = true
// Выполняется привязка следующего элемента последовательности к связанному локальному параметру i
// Выполняется проверка условия where:
// Данный элемент последовательности связанный с локальным параметром i % 2 == 0 = true

// Выполняется итерация № 5:
// result += i (20 += 10) (result = 30)

/// Переход в начало

// Имеются ли ещё значения в данной последовательности ? = false
/// Выход

// Сочетание if и for - in
/// Данный выриант менее читабельный, но менее ресурсозатратный

var isRun = false

if isRun { // Если условие if = false то проверка произойдет только 1 раз и произойдет выход из if с вложенным for - in, который, соответственно не будет выполнен
    for i in 1...10 {
        print(i)
    }
}

// Более читаемый вариант, но ресурсозатратнее
for i in 1...10 where isRun {
    print(i)
}

// Так как where идет после for - in то его проверка будет выполнена столько раз, сколько for - in будет true (будет происходить проверка на наличие значений в последовательности и привязка текущего значения из последовательности к ассоциируемому значению i, и только после этого будет выполняться проверка условия в where, и только когда все перебираемые значения в последовательности закончатся - только после этого произойдет выход из цикла for-in-where)

/// Вход
// Проверка for - in №1: = true
// привязка к i

// Проверка where №1 = false

/// Переход в начало

// Проверка for - in №2: = true
// привязка к i

// Проверка where №2 = false

/// Переход в начало

// Проверка for - in №3: = true
// привязка к i

// Проверка where №3: = false

/// Переход в начало

// Проверка for - in №4: = true
// привязка к i

// Проверка where №4: = false

/// Переход в начало

// Проверка for - in №5: = true
// привязка к i

// Проверка where №5: = false

/// Переход в начало

// Проверка for - in №6: = true
// привязка к i

// Проверка where №6: = false

/// Переход в начало

// Проверка for - in №7: = true
// привязка к i

// Проверка where №7: = false

/// Переход в начало

// Проверка for - in №8: = true
// привязка к i

// Проверка where №8: = false

/// Переход в начало

// Проверка for - in №9: = true
// привязка к i

// Проверка where №9: = false

/// Переход в начало

// Проверка for - in №10: = true
// привязка к i

// Проверка where №10: = false

/// Переход в начало

// Проверка for - in №11: = false
/// Выход



// Многомерные коллекции в конструкции цикла for-in
// Вложение for - in в for - in

// resultOfGames - словарь массивов с типом: [String : [String]]
let resultOfGames = ["Red Wings": ["2:1","2:3"], "Capitals": ["3:6","5:5"], "Penguins": ["3:3","1:2"]]

for (teamName, results) in resultOfGames {
    // Обработка словаря
    print(results)
    for oneResult in results {
        // Обработка массива результатов игр
        print("Игра с \(teamName) - \(oneResult)")
    }
}

/// Вход
// Выполняется проверка ОСНОВНОГО for: имеются ли данные для обработки (пара ключей/значений) в этом словаре массивов resultOfGames? = true

// Выполняется привязка ключа из словаря массивов к ассоциативному_параметру teamName
// Выполняется привязка значения в формате массива к ассоциативному_параметру results

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли данные для обработки в параметре results? = true

/* В новый объявленный ассоциативный_параметр oneResult (во вложенном for) передаётся обработанный массив из значений, который был получен из основного for, где ассоциативный_параметр results принимал массив из значений из словаря массивов resultOfGames
Теперь он передает эти значения связанному ассоциативному параметру oneResult во вложенный цикл for, что объявлен в теле цикла for которые теперь обрабатываются
От колл-ва значений будет зависеть колл-во итераций во вложенном if */


/* К 1-у ключу привязанно 2-ва значения в виде массива, поэтому print() будет срабатывать 2 раза */

// Выполняется итерация № 1: print("Игра с \(teamName) - \(oneResult)")
// Выводится в консоль содержимое (ключ) ассоциативного_параметра teamName из ОСНОВНОГО for:
// Выводится в консоль содержимое (значение) ассоциативного_параметра oneResult из ВЛОЖЕННОГО for:

// Выполняется итерация № 2: print("Игра с \(teamName) - \(oneResult)")
// Ещё раз выводится в консоль содержимое (ключ) ассоциативного_параметра teamName из ОСНОВНОГО for:
// Выводится в консоль содержимое (значение) ассоциативного_параметра oneResult из ВЛОЖЕННОГО for:

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли ещё данные для обработки в параметре results? = false

/// Переход в ОСНОВНОЙ for

// Выполняется проверка ОСНОВНОГО for: имеются ли данные для обработки (пара ключей/значений) в этом словаре массивов resultOfGames? = true

// Выполняется привязка ключа из словаря массивов к ассоциативному_параметру teamName
// Выполняется привязка значения в формате массива к ассоциативному_параметру results

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли данные для обработки в параметре results? = true
// В ассоциативный параметр oneResult передается обработанный массив значений из ассоциативного параметра results

// Выполняется итерация № 3: print("Игра с \(teamName) - \(oneResult)")
// Выводится в консоль содержимое (ключ) ассоциативного_параметра teamName из ОСНОВНОГО for:
// Выводится в консоль содержимое (значение) ассоциативного_параметра oneResult из ВЛОЖЕННОГО for:

// Выполняется итерация № 4: print("Игра с \(teamName) - \(oneResult)")
// Ещё раз выводится в консоль содержимое (ключ) ассоциативного_параметра teamName из ОСНОВНОГО for:
// Выводится в консоль содержимое (значение) ассоциативного_параметра oneResult из ВЛОЖЕННОГО for:

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли ещё данные для обработки в параметре results? = false

/// Переход в ОСНОВНОЙ for

// Выполняется проверка ОСНОВНОГО for: имеются ли данные для обработки (пара ключей/значений) в этом словаре массивов resultOfGames? = true

// Выполняется привязка ключа из словаря массивов к ассоциативному_параметру teamName
// Выполняется привязка значения в формате массива к ассоциативному_параметру results

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли данные для обработки в параметре results? = true
// В ассоциативный параметр oneResult передается обработанный массив значений из ассоциативного параметра results

// Выполняется итерация № 5: print("Игра с \(teamName) - \(oneResult)")
// Выводится в консоль содержимое (ключ) ассоциативного_параметра teamName из ОСНОВНОГО for:
// Выводится в консоль содержимое (значение) ассоциативного_параметра oneResult из ВЛОЖЕННОГО for:

// Выполняется итерация № 6: print("Игра с \(teamName) - \(oneResult)")
// Ещё раз выводится в консоль содержимое (ключ) ассоциативного_параметра teamName из ОСНОВНОГО for:
// Выводится в консоль содержимое (значение) ассоциативного_параметра oneResult из ВЛОЖЕННОГО for:

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли ещё данные для обработки в параметре results? = false

/// Переход в ОСНОВНОЙ for

// Выполняется проверка ОСНОВНОГО for: имеются ли данные для обработки (пара ключей/значений) в этом словаре массивов resultOfGames? = false
/// Выход



// continue в конструкции цикла for - in
for i in 1...10 {
    if i % 2 == 0 {
        continue
    }
    print(i)
}



// break в конструкции цикла for - in
// break - прервать
// Как только условие становится true, то break прерывает работу текущего цикла

for i in 1...10 {
    if i == 5 {
        break
    }
    print(i)
}

// break + метка
// Пример метки - mainLoop:
// При использовании метки перед основном for и оператора break с указанием метки (break mainLoop) во вложенным for, в котором в качестве проверки условия срабатывания break mainLoop используется if, то произойдет принудительный выход как из вложенного for, так и из основного for с помощью метки

// Без использования метки перед основным for:
print("Enter")
mainLoop: for i in 1...5 {
    print(i)
    for y in 1...5 {
        if y == 4 && i == 2 {
            break
        }
        print("\(i) - \(y)")
    }
}

// С использованием метки перед основным for:
print("Enter")
mainLoop: for i in 1...5 {
    print(i)
    for y in 1...5 {
        if y == 4 && i == 2 {
            break mainLoop
        }
        print("\(i) - \(y)")
    }
}

/// Вход
// Выполняется проверка ОСНОВНОГО mainLoop: for: имеются ли значения для обработки в этом диапазоне? = true
// Выполняется привязка значения из диапазона к ассоциативному_параметру i

// Выполняется итерация №1 в теле ОСНОВНОГО (метка) for:
// print(i)

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли значения для обработки в этом диапазоне? = true
// Выполняется привязка значения из диапазона к ассоциативному_параметру y

// Выполняется проверка ВЛОЖЕННОГО if:
// if y == 4 && i == 2 = false

// Выполняется итерация №1 в теле ВЛОЖЕННОГО for:
// print("\(i) - \(y)")

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли значения для обработки в этом диапазоне? = true
// Выполняется привязка текущего значения из диапазона к ассоциативному_параметру y

// Выполняется проверка ВЛОЖЕННОГО if:
// if y == 4 && i == 2 = false

// Выполняется итерация №2 в теле ВЛОЖЕННОГО for:
// print("\(i) - \(y)")

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли значения для обработки в этом диапазоне? = true
// Выполняется привязка текущего значения из диапазона к ассоциативному_параметру y

// Выполняется проверка ВЛОЖЕННОГО if:
// if y == 4 && i == 2 = false

// Выполняется итерация №3 в теле ВЛОЖЕННОГО for:
// print("\(i) - \(y)")

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли значения для обработки в этом диапазоне? = true
// Выполняется привязка текущего значения из диапазона к ассоциативному_параметру y

// Выполняется проверка ВЛОЖЕННОГО if:
// if y == 4 && i == 2 = false

// Выполняется итерация №4 в теле ВЛОЖЕННОГО for:
// print("\(i) - \(y)")

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли значения для обработки в этом диапазоне? = true
// Выполняется привязка текущего значения из диапазона к ассоциативному_параметру y

// Выполняется проверка ВЛОЖЕННОГО if:
// if y == 4 && i == 2 = false

// Выполняется итерация №5 в теле ВЛОЖЕННОГО for:
// print("\(i) - \(y)")

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли значения для обработки в этом диапазоне? = false

/// Переход в ОСНОВНОЙ for

// Выполняется проверка ОСНОВНОГО mainLoop: for: имеются ли значения для обработки в этом диапазоне? = true
// Выполняется привязка значения из диапазона к ассоциативному_параметру i

// Выполняется итерация №2 в теле ОСНОВНОГО (метка) for:
// print(i)

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли значения для обработки в этом диапазоне? = true
// Выполняется привязка значения из диапазона к ассоциативному_параметру y

// Выполняется проверка ВЛОЖЕННОГО if:
// if y == 4 && i == 2 = false

// Выполняется итерация №6 в теле ВЛОЖЕННОГО for:
// print("\(i) - \(y)")

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли значения для обработки в этом диапазоне? = true
// Выполняется привязка значения из диапазона к ассоциативному_параметру y

// Выполняется проверка ВЛОЖЕННОГО if:
// if y == 4 && i == 2 = false

// Выполняется итерация №7 в теле ВЛОЖЕННОГО for:
// print("\(i) - \(y)")

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли значения для обработки в этом диапазоне? = true
// Выполняется привязка значения из диапазона к ассоциативному_параметру y

// Выполняется проверка ВЛОЖЕННОГО if:
// if y == 4 && i == 2 = false

// Выполняется итерация №8 в теле ВЛОЖЕННОГО for:
// print("\(i) - \(y)")

// Выполняется проверка ВЛОЖЕННОГО for: имеются ли значения для обработки в этом диапазоне? = true
// Выполняется привязка значения из диапазона к ассоциативному_параметру y

// Выполняется проверка ВЛОЖЕННОГО if:
// if y == 4 && i == 2 = true
// Выполняется код в теле ВЛОЖЕННОГО if:
// break mainLoop
/// break - прерывается текущий цикл ВЛОЖЕННОГО for
/// mainLoop - прерывается текущий цикл ОСНОВНОГО for
/// ВЫХОД



// Оператор досрочного выхода guard

/*
 guard проверяемое_условие else {
 // тело оператора
 }
 */

// Подобно оператору if он проверяет истинность переданного условия
// Выполняет код в теле только в том случает, если проверяемое условие возвращает false
// Тело оператора должно ОБЯЗАТЕЛЬНО содержать один из следующих операторов:

// break
// continue
// throw
// return
