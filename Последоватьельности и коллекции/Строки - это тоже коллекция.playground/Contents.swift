// Character в составе String

var str = "Swift"

str.count
str.isEmpty
str.append("y")

for value in str {
    print(value)
}

// параметру типа Character инициализируется символ "é" с использованием одного юникод-скаляра \u{E9}

let char: Character = "\u{E9}"

// параметру типа Character инициализируется символ "é" с использованием двух юникод-скаляров. Первый будет описывать латинскую букву e (\u{65}), а второй — символ ударения (\u{301})

// так как тип данных этих параметров — Character, ясно, что в обоих случаях для Swift значение состоит из одного символа.

let sumChar: Character = "\u{65}\u{301}"

// в константе sumrChar содержится комбинированный символ \u{65}\u{301}, состоящий из двух кодовых точек и, по сути, являющийся одним полноценным символом.

// Существование таких комбинированных символов становится возможным благодаря специальным символам, модифицирующим предыдущий по отношению к ним символ (как знак ударения в листинге выше, он изменяет отображение латинской буквы e).

char == sumChar

// Графем-кластеры

// Графем-кластер — это совокупность юникод-скаляров (или кодовых точек), при визуальном представлении выглядящих как один символ.

// Графем-кластеры могут определять не только буквы алфавита, но и эмодзи

let thumbsUp = "\u{1f44d}"
let blackSkin = "\u{1f3fd}"
let combine = "\u{1f44d}\u{1f3fd}"

let cafeSimple = "caf\u{E9}"
let cafeCombine = "cafe\u{301}"

// для Swift строка — это коллекция символов, каждый из которых является графем-кластером.

cafeSimple == cafeCombine


// Строковые индексы

// Значение типа String имеет несколько свойств, позволяющих получить индекс определенных элементов.

// Свойство startIndex - возвращающий индекс графем-кластера первого элемента строки

// Получаем индекс первого графем-кластера с помощью свойства startIndex - возвращающий индекс графем-кластера первого элемента строки
let name: String = "e\u{301}lastic"

name.startIndex

//  Получть индекс и символ по индексу

// 1.
// в строковом литерале запрашиваем индекс первого графем-кластера у строки name
// в строковом литерале появился индекс, применим его к строке name, чтобы получить символ по данному индексу
name[name.startIndex]

// Еще примеры
let test = "ABCD"
test[test.startIndex]

let sumString = "~!@#$%^"
sumString[sumString.startIndex]


// 2.
let sumName = "e\u{301}lastic"

// 1. Обьявляем константу index, инициализируем ей индекс графем-кластера первого символа строки константы name
let index = sumName.startIndex

// Теперь в константе index хранится индекс первой буквы, и его можно использовать точно так же, как индексы других коллекций
// Обьявляем константу element, инициализируем ей индекс графем-кластера первого символа строки которой мы получили, открываем индексный литерал и указываем константу index что хранит индекс константы name
let element = sumName[index]
type(of: element)



// Свойство endIndex - позволяющее получить индекс графем-кластера, который следует за последним символом в строке. Таким образом, он указывает не на последний графем-кластер, а за него, туда, куда будет добавлен новый графем-кластер. Если вы попытаетесь использовать значение свойства endIndex напрямую, то Swift сообщит о критической ошибке

// name[name.endIndex] error

// name[indexLastChar] error

// Метод index(before:) - позволяет получить индекс графем-кластера, предшествующего тому, индекс графем-кластера которого передан в качестве аргумента в before.

// Метод index(before:) + cвойство endIndex - получить индекс последнего графем-кластера

// 1. получаем идекс графем-кластера и инициализируем его константе
let indexLastChar = name.endIndex

// 2. получаем индекс последнего графем-кластера
let lastCharIndex = name.index(before: indexLastChar)

// 3. указываем индекс последнего графем-кластера и получаем расположенный элемент по данному индексу
name[lastCharIndex]


// Метод index(after:) позволяет получить индекс последующего графем-кластера тому, индекс графем-кластера которого передан в качестве аргумента в after.

// 1
name[name.index(after: name.startIndex)]

// 2
let afterCharIndex = name.index(after: index)
name[afterCharIndex]


// Метод index(_:offsetBy:) позволяет получить требуемый символ с учетом отступа вправо. В качестве первого аргумента передается индекс графем-кластера, от которого будет происходить отсчет, а в качестве второго агрумента в offsetBy передается целое число, указывающее на отступ вправо.

// 1
let fourCharIndex = name.index(name.startIndex, offsetBy: 3)
name[fourCharIndex]

// 2
name[name.index(name.startIndex, offsetBy: 3)]


// свойство unicodeScalars - получить доступ к коллекции юникод-скаляров

name
name.count // подсчет графем-кластеров
name.unicodeScalars.count // подсчет юникод-скаляров, т.к первый графем-кластер состоит из 2 юникод-скаляров

// Подстроки
let abc = "abcdefghijklmnopqrstuvwxyz"

// индекс первого символа
let firstCharIndex = abc.startIndex

// индекс четвертого символа
let fourthCharIndex = abc.index(firstCharIndex, offsetBy:3)

// получим подстроку
let subAbc = abc[firstCharIndex...fourthCharIndex]
type(of: subAbc)

// полуоткрытый диапазон в подстроках
let subStr = abc[fourthCharIndex...]

// преобразования подстроки в строку
type( of: String(subAbc) ) // String.Type

// пример использования полуоткрытого оператора диапазона для получения подстроки
var sumStr = abc[fourthCharIndex...]
subStr // "defghijklmnopqrstuvwxyz"
