// Перечисление (enum) — это тип данных, содержащий множество альтернативных значений, каждое из которых может быть проинициализировано константе.

// Рассматривайте его как набор констант, значения которых являются альтернативами друг другу.

// Синтаксис
/*
 enum ИмяПеречисления {
 
     case значение1
 
     case значение2
 
     // другие значения
 
 }
 
 Значение — значение очередного члена перечисления.»
 
 */

// ПРИМЕЧАНИЕ: Объявляя перечисление, вы создаете новый тип данных.

// 1
enum CurrencyUnit {
    case rouble
    case euro
}

// 2
enum sumCurrencyUnit {
    case rouble, euro
}

// После создания нового перечисления одно из его значений (членов перечисления) может быть присвоено параметру (переменной или константе), для этого используется специальный синтаксис.

// Краткий синтаксис
var roubleCurrency: CurrencyUnit = .rouble

// Полный синтаксис
var otherCurrency = CurrencyUnit.euro

// Cоздаются две переменные типа CurrencyUnit, каждая из которых в качестве значения содержит определенный член перечисления CurrencyUnit.



// Ассоциированные параметры

// У каждого из членов перечисления могут быть ассоциированные с ним значения, то есть его характеристики. Они указываются для каждого члена  в круглых скобках с указанием имен и типов, разделенных двоеточием.

// Набор ассоциированных параметров может быть уникальным для каждого отдельного члена.

// Создадим новое перечисление AdvancedCurrencyUnit, основанное на CurrencyUnit, но имеющее ассоциированные параметры, с помощью которых можно указать список стран, где данная валюта используется, а также краткое наименование валюты

enum AdvancedCurrencyUnit {
    case rouble(countries: [String], shortName: String)
    case euro(countries: [String], shortName: String)
}

// ПРИМЕЧАНИЕ: При описании ассоциированных параметров не обязательно указывать их имена, можно обойтись лишь типами данных.
/*
 enum AdvancedCurrencyUnit {
 case rouble([String], String)
 case euro ([String], String)
 }
 */
// Оба члена перечисления содержат одинаковые ассоциированные параметры. Параметр countries является массивом, так как валюта может использоваться не в одной, а в нескольких странах: например, евро используется на территории Европейского союза.

// В константе euroCurrency хранится член euro со значениями его двух ассоциированных параметров.

let euroCurrency: AdvancedCurrencyUnit = .euro(countries: ["German", "France"], shortName: "EUR")


// Ассоциированные параметры могут различаться для каждого члена перечисления. расширим возможности перечисления AdvancedCurrencyUnit, добавив в него новый член, описывающий доллар. При этом ассоциированные с ним параметры будут отличаться от параметров уже имеющихся членов.

// Создадим еще одно перечисление DollarCountries и укажем его в качестве типа данных ассоциированного параметра нового члена перечисления ExampleAdvancedCurrencyUnit

enum DollarCountries {
    case usa
    case canada
    case australia
}

enum ExampleAdvancedCurrencyUnit {
    case rouble(countries: [String], shortName: String)
    case euro(countries: [String], shortName: String)
    case dollar(nation: DollarCountries, shortName: String)
}

// Для параметра nation члена dollar перечисления AdvancedCurrencyUnit используется тип данных DollarCountries.


var dollarCurrency: ExampleAdvancedCurrencyUnit = .dollar(nation: .usa, shortName: "USD")

dollarCurrency = .dollar(nation: .australia, shortName: "USD")
dollarCurrency = .dollar(nation: .canada, shortName: "USD")



// Вложенные перечисления
// Перечисления могут быть частью других перечислений, то есть могут быть определены в области видимости родительских перечислений.

enum SumAdvancedCurrencyUnit {
    enum SumDollarCountries {
        case usa
        case canada
        case australia
    }
    case rouble (countries: [String], shortName: String)
    case euro (countries: [String], shortName: String)
    case dollar (nation: SumDollarCountries, shortName: String)
}

// Теперь перечисление DollarCountries обладает ограниченной областью видимости и доступно только через родительское перечисление. Можно сказать, что это подтип типа, или вложенный тип. Тем не менее при необходимости вы можете создать параметр, содержащий значение этого перечисления, и вне перечисления sumAdvancedCurrencyUnit

// Так как перечисление DollarCountries находится в пределах перечисления AdvancedCurrencyUnit, обращаться к нему необходимо как к свойству этого типа, то есть через точку

let australia: SumAdvancedCurrencyUnit = .dollar(nation: .australia, shortName: "USD")



// Switch и связывание значения именованных ассоциациированных параметров членов перечисления

// связывание значения именованных ассоциациированных параметров членов enum в данном примере оправданно только по причине использования интерполяции, т.e для того, чтобы была возможность использовать имена значений параметров членов enum в теле case в print()
/*
enum ExampleAdvancedCurrencyUnit {
    case rouble(countries: [String], shortName: String)
    case euro(countries: [String], shortName: String)
    case dollar(nation: DollarCountries, shortName: String)
}
*/

dollarCurrency = .euro(countries: ["Germany, Austria"], shortName: "EUR")

// 1
switch dollarCurrency {
case let .rouble(countries, shortName):
    print("\(countries), \(shortName)")
case let .euro(countries, shortName):
    print("\(countries), \(shortName)")
case let .dollar(nation, shortName):
    print("\(nation), \(shortName)")
}

// 2

switch dollarCurrency {
case .rouble(let countries, let shortName):
    print("\(countries) и \(shortName)")
case .euro(let countries, let shortName):
    print("\(countries) и \(shortName)")
case .dollar(let nation , let shortName):
    print("\(nation) и \(shortName)")
}


// без интерполяции, поэтому ассоциируемые параметры членов перечисления не указываются

// 1
switch dollarCurrency {
case .rouble:
    print("1")
case .euro:
    print("2")
case .dollar:
    print("3")
}


// 2. Ассоциирумемые параметры членов перечисления заменены на _ по причние неиспользуемости
switch dollarCurrency {
case .rouble(_, _):
     print("1")
case .euro(_, _):
     print("2")
case .dollar(_, _):
     print("3")
 }



// Switch, Усов

// Просто так удалил ассоц. парамаетры rouble
// 2 и 3 case - синонимы

 switch dollarCurrency {
 case .rouble:
     print("1")
 case let .euro(countries, shortname):
     print("\(countries) и \(shortname)")
 case .dollar(let nation, let shortname):
     print("\(nation) и \(shortname)")
 }



// как должно быть изначально
switch dollarCurrency {
case let .rouble(countries, shortName):
    print("\(countries) и \(shortName)")
case let .euro(countries, shortName):
    print("\(countries) и \(shortName)")
case let .dollar(nation, shortName):
    print("\(nation) и \(shortName)")
}



// Связанные (сырые, исходные) значения членов перечисления

// Связанное значение - задание для каждого члена перечисления определенный тип данных с каким-либо значением

// Одновременное определение исходных значений и ассоциированных параметров запрещено

// В качестве связанных значений членов этого перечисления указаны значения типа String

enum Smile: String {
    case joy = ":)"
    case laugh = ":D"
    case sorrow = ":("
    case surprise = "o_O"
}

// Связанные значения и ассоциированные параметры не одно и то же. Первые устанавливаются при определении перечисления, причем обязательно для всех его членов и в одинаковом типе данных. Ассоциированные параметры могут быть различны для каждого перечисления и устанавливаются лишь при инициализации члена перечисления в качестве значения.

// Если в качестве типа данных перечисления указать Int, то исходные значения создаются автоматически путем увеличения значения на единицу для каждого последующего члена (значение первого члена равно 0)

enum planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune, pluto = 999
}
// Для первого члена перечисления в качестве исходного значения указано целое число 1. Для каждого следующего члена значение увеличивается на единицу, так как не указано иное: для venus — это 2, для earth — 3 и т. д.

// Для члена pluto связанное значение указано конкретно, поэтому оно равно 999.



// Доступ к связанным значениям

// При создании экземпляра перечисления можно получить доступ к исходному значению члена этого экземпляра перечисления. Для этого используется свойство rawValue.

// Создадим экземпляр объявленного ранее перечисления Smile и получим исходное значение члена перечисления установленного в этом экземпляре.

// В результате использования свойства rawValue мы получаем исходное значение члена joy типа String.

let iAnHappy = Smile.joy
iAnHappy.rawValue

planet.mercury.rawValue
planet.venus.rawValue
planet.earth.rawValue
planet.pluto.rawValue



// Инициализатор — это метод в составе объектного типа (перечисления, структуры или класса), имеющий имя init.

// Перечисления имеют всего один инициализатор init(rawValue:)
// Он позволяет передать связанное значение, соответствующее требуемому члену перечисления.
// Таким образом, у нас есть возможность инициализировать параметру конкретный член перечисления по связанному с ним значению.

// Инициализатор перечисления Planet — это метод init(rawValue:).
// Ему передается указатель на исходное значение, связанное с искомым членом этого перечисления.

let myPlanet = planet.init(rawValue: 3)

var anotherPlanet = planet.init(rawValue: 11)

// Данный метод не описан в теле перечисления, — он существует там всегда по умолчанию и закреплен в исходном коде языка Swift.

// Инициализатор init(rawValue:) возвращает опционал, поэтому если вы укажете несуществующее связанное значение, вернется nil.


// Инициализаторы вызываются каждый раз при создании нового экземпляра какого-либо перечисления, структуры или класса.
// Для некоторых конструкций их можно и нужно создавать самостоятельно, а для некоторых, вроде перечислений, они существуют по умолчанию.

// Инициализатор выполняет установку всех требуемых значений для параметров с непосредственным созданием экземпляра и помещением его в хранилище.

// Инициализатор — это всегда метод с именем init.



// Вычисляемые свойства в перечислениях

// Свойство — это переменные или константы, объявленное в пределах структуры или класса, доступ к которому осуществляется через экземпляр структуры или класса.

// В Swift существует определенное ограничение для свойств в перечислениях: в качестве их значений не могут выступать фиксированные значения-литералы, только замыкания.

// Такие свойства называются вычисляемыми. При каждом обращении к ним происходит вычисление присвоенного замыкания с возвращением получившегося значения.

// Для вычисляемого свойства после имени через двоеточие указывается тип возвращаемого значения и далее без оператора присваивания в фигурных скобках — тело замыкающего выражения, генерирующего возвращаемое значение.

// Объявим вычисляемое свойство для разработанного ранее перечисления.

// За основу возьмем перечисление Smile и создадим вычисляемое перечисление, которое возвращает связанное с текущим членом перечисления значение.

// Вычисляемое свойство должно быть объявлено как переменная. В противном случае вы получите сообщение об ошибке.

// С помощью оператора self внутри замыкания вы получаете доступ к текущему члену перечисления.

enum Smiles: String {
    case joy = ":)"
    case laugh = ":D"
    case sorrow = ":("
    case surprise = "o_O"
    
    // вычисляемое свойство-замыкание
    var description: String {
        return self.rawValue
    }
}

// создадим экземпляр пречисления Smiles и выберем член перечисления
let mySmiles: Smiles = .sorrow

// вычисляемое свойство - верни мне связанное значение записанного в константу выбранного члена перечисления
mySmiles.description



// Методы (Property) в перечислениях

// Перечисления могут группировать в себе не только свойства, члены и другие перечисления, но и методы.

// Методы — это функции внутри перечислений, поэтому их синтаксис и возможности идентичны синтаксису и возможностям изученных ранее функций.

// Ранее мы говорили об инициализаторах init(), которые являются встроенными в перечисления методами.

// Вернемся к примеру с перечислением Smile и создадим метод, который выводит на консоль справочную информацию о предназначении перечисления.

enum SumSmile: String {
    case joy = ":)"
    case laugh = ":D"
    case sorrow = ":("
    case suprise = "o_O"
    
    var description: String {
        return self.rawValue
    }
    
    func about () -> Void {
        print("Перечисления содержит список смайликов")
    }
}
// создаем экземпляр перечисления SumSmile и выбираем его член
var anotherSmile: SumSmile = .joy

// обращаемся к переменной-экземпляру перечисления и вызываем метод
anotherSmile.about()



// Оператор self

// Для доступа к значению перечисления внутри этого перечисления используется оператор self

// Данный оператор возвращает указатель на текущий конкретный член перечисления, инициализированный параметру.


// Оператор self используется внутри перечисления в двух случаях:
//для доступа к текущему члену перечисления;
//для доступа к свойствам и методам перечисления (начиная со Swift 5.3 использование self не является обязательным и данный оператор может быть опущен.)


enum Smilee: String {
    case joy = ":)"
    case laugh = ":D"
    case sorrow = ":("
    case surprise = "o_O"
    
    var description: String {
        return rawValue
    }
    
    func about () -> Void {
        print("Перечисление содержит список смайликов")
    }
    
    func descriptionValue() -> Smilee {
        return self
    }
    
    func descriptionRawValue() -> String {
        // использование self перед rawValue не является обязательным
        return rawValue
    }
}
var exampleSelf: Smilee = .joy
// При вызове метода descriptionValue() происходит возврат self, то есть самого экземпляра. Именно поэтому тип возвращаемого значения данного метода — Smile, он соответствует типу экземпляра перечисления.
exampleSelf.descriptionValue()

// Метод descriptionRawValue() возвращает связанное значение члена данного экземпляра
// при этом использование self не является обязательным. Swift из контекста понимает, к какому именно параметру вы пытаетесь обратиться.
exampleSelf.descriptionRawValue()
