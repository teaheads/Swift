/*
 СИНТАКСИС
    class ИмяКласса {
        // свойства и методы класса
    }
 */

// Свойства классов

// класс имеет один встроенный инициализатор, который является пустым.
// Если у структуры инициализатор генерируется автоматически вместе с изменением состава ее свойств, то у класса для инициализации значений свойств требуется разрабатывать инциализаторы самостоятельно.

// При создании экземпляра класса каждому свойству должно быть проинициализи- ровано значение: либо через значения по умолчанию, либо в теле инициализатора.

// Использование класса для моделирования шахматной фигуры предпочтительнее в первую очередь в связи с тем, что каждая отдельная фигура — это уникальный объект со своими характеристиками.
// Его модификация в программе с использованием ссылок (а класс — это ссылочный тип) значительно упростит работу.

// Рассмотрим пример использования классов.
//Необходимо смоделировать сущность «шахматная фигура». При этом она должна обладать следующим набором свойств:
// тип фигуры;
// цвет фигуры;
// координаты на игровом поле.

//В еще одном дополнительном свойстве мы будем хранить символ, соответствующий шахматной фигуре (в составе стандарта Unicode присутствуют необходимые символы).

// Координаты будут служить не только для определения местоположения фигуры на шахматной доске, но и для определения факта ее присутствия. Если фигура взята или еще не выставлена, то значение координат будет nil.

// Так как у класса будут определены свойства, необходимо разработать инициали- затор, который будет устанавливать их значения.
/*

class Chessman {
    let type: String
    let color: String
    var coordinates: (String, Int)? = nil
    let figureSymbol: Character
    
    init(type: String, color: String, figure: Character) {
        self.type = type
        self.color = color
        figureSymbol = figure
    }
}

var kingWgite = Chessman(type: "King", color: "White", figure: "\u{2654}")

*/

// В результате выполнения кода в переменной kingWhite находится экземпляр клас- са Chessman, описывающий фигуру «Белый король».

// Фигура еще не имеет координат, а значит, не выставлена на игровое поле (ее координаты соответствуют nil).

// Обратите внимание, что для доступа к свойству figureSymbol мы не ис- пользуем self, но при желании вы можете его добавить.
// Использование self для доступа к свойствам type и color обусловлено тем, что входные параметры инициализатора имеют те же самые имена, что и свойства класса.

// Тип данных свойства coordinate является опциональным кортежем.
// Это связано с тем, что фигура может быть убрана с игрового поля (тогда свойство будет nil). Координаты фигуры на шахматном поле задаются с помощью строки и числа.

// В разработанном инициализаторе указаны входные аргументы, значения которых используются в качестве значений свойств экземпляра.

// Свойства type и color могут принять значения из четко определенного перечня, поэтому имеет смысл реализовать два перечисления:
// одно должно содержать типы шахматных фигур, второе — цвета

enum ChessmanType {
    case king, castle, bishop, pawn, knight, queen
}

enum ChessmanColor {
    case white, black
}

// Созданные перечисления должны найти место в качестве типов соответствующих свойств класса Chessman. Не забывайте, что и входные аргументы инициализатора должны измениться соответствующим образом.

/*
class Chessman {
    let type: ChessmanType
    let color: ChessmanColor
    var coordinates: (String, Int)? = nil
    let figureSymbol: Character
    
    init(type: ChessmanType, color: ChessmanColor, figure: Character) {
        self.type = type
        self.color = color
        figureSymbol = figure
    }
}

// Теперь при создании модели шахматной фигуры необходимо передавать значения типов ChessmanType и ChessmanColor вместо String.

var kingWhite = Chessman(type: .king, color: .white, figure: "\u{2654}")
*/

// Созданные дополнительные связи обеспечивают корректность ввода данных при создании экземпляра класса.

// Методы классов

// в классах нет необходимости использовать ключевое слово mutating для методов, меняющих значения свойств.

// Немного оживим созданную модель шахматной фигуры, создав несколько методов, решающих следующие задачи:

// установка координат фигуры (при выставлении на поле или при движении);
// снятие фигуры с игрового поля (окончание партии или взятие фигуры).

/*

class Chessman {
    let type: ChessmanType
    let color: ChessmanColor
    var coordinates: (String, Int)? = nil
    let figureSymbol: Character
    
    init(type: ChessmanType, color: ChessmanColor, figure: Character) {
        self.type = type
        self.color = color
        figureSymbol = figure
    }
    
    func setCoordinates(c: String, n: Int) -> Void {
        coordinates = (c, n)
    }
    
    func kill() -> Void {
        coordinates = nil
    }
}

let kingWhite = Chessman(type: .king, color: .white, figure: "\u{2654}")

// В результате фигура «Белый король» выставляется в позицию с координатами E1.
kingWhite.setCoordinates(c: "E", n: 1)

// В результате фигура «Белый король» не имеет координатов
kingWhite.kill()

*/
 

// Инициализаторы классов
// Класс может содержать произвольное количество разработанных инициализаторов, различающихся лишь набором входных аргументов. Это никоим образом не влияет на работу самого класса, а лишь дает нам более широкие возможности при создании его экземпляров.

// Рассмотрим процесс создания дополнительного инициализатора. Существующий класс Chessman не позволяет одним выражением создать фигуру и выставить ее на поле. Сейчас для этого используются два независимых выражения. Давайте разработаем второй инициализатор, который будет дополнительно принимать координаты фигуры

/*

class Chessman {
    let type: ChessmanType
    let color: ChessmanColor
    var coordinates: (String, Int)? = nil
    let figureSymbol: Character
    
    init(type: ChessmanType, color: ChessmanColor, figure:Character){
            self.type = type
            self.color = color
            figureSymbol = figure
        }
    
    init(type: ChessmanType, color: ChessmanColor, figure: Character, coordinates: (String, Int)) {
        self.type = type
        self.color = color
        figureSymbol = figure
        setCoordinates(c: coordinates.0, n: coordinates.1)// параметры кортежа по индексу
        
    }
    func setCoordinates(c: String, n: Int) -> Void {
        coordinates = (c, n)
    }
    
    func kill() -> Void {
        coordinates = nil
    }
}

var queenBlack = Chessman(type: .queen, color: .black, figure: "\u{2655}", coordinates: ("A", 3))
 
*/
 
// Так как код установки координат уже написан в методе setCoordinates(char:num:), то во избежание дублирования в инициализаторе этот метод просто вызывается.

// Объявляется переменная queenBlack, ей присваивается тип данных Chessman, таким образом она становится экземпляром класса Chessman

// Далее ей инициализируются свойства класса через инициализатор класса Chessman

// Во входной параметр инициализатора coordinates задается аргумент ("A", 3) в формате кортежа

// далее в он попадает в тело инициализатора

// в теле инициализатора вызывается метод setCoordinates, который принимает во входные параметры индекс элементов свойства coordinates, где:

// c: coordinates.0, n: coordinates.1 - индексы элементов кортежа свойства coordinates

// вызов метода setCoordinates

// в теле метода setCoordinates аргументы ("A", 3) присваиваются свойству coordinates класса Chessman

// таким образом экземпляр queenBlack класса Chessman имеет свойство coordinates со значением ("A", 3)



// Вложенные в класс объктные типы

// Очень часто перечисления, структуры и классы создаются для того, чтобы расширить функциональность и удобство использования определенного типа данных.

// Такой подход мы встречали, когда разрабатывали перечисления ChessmanColor и ChessmanType, использующиеся в классе Chessman. В данном случае перечисления нужны исключительно в контексте класса, описывающего шахматную фигуру, и нигде больше.

// В такой ситуации вы можете вложить перечисления в класс, то есть описать их не глобально, а в пределах тела класса

// Структуры ChessmanColor и ChessmanType теперь являются вложенными в класс Chessman и существуют только в пределах области видимости данного класса.

/*

class Chessman {
    
    enum ChessmanType {
        case king, castle, bishop, pawn, knight, queen
    }
    
    enum ChessmanColor {
        case black, white
    }
    
    let type: ChessmanType
    let color: ChessmanColor
    var coordinates: (String, Int)? = nil
    let figureSymbol: Character
    
    init(type: ChessmanType, color: ChessmanColor, figure:
        Character) {
        self.type = type
        self.color = color
        figureSymbol = figure
}
    init(type: ChessmanType, color: ChessmanColor, figure:
        Character, coordinates: (String, Int)) {
        self.type = type
        self.color = color
        figureSymbol = figure
        setCoordinates(char: coordinates.0, num:coordinates.1)
    }
    func setCoordinates(char c:String, num n: Int) {
        coordinates = (c, n)
    }
func kill() {
        coordinates = nil
    }
}

let figure = Chessman(type: .queen, color: .black, figure: "\u{2655}", coordinates: ("B", 7))

// Ссылки на вложенные в класс объектные типы

let linkToEnumValue = Chessman.ChessmanType.bishop
let linkedToEnumValue = Chessman.ChessmanColor.black



// Свойства
// Свойства — это параметры, объявленные в пределах объектного типа данных.

// По типу значения можно выделить два основных вида свойств:

// хранимые свойства могут использоваться в структурах и классах;
 
// вычисляемые свойства могут использоваться в перечислениях, структурах и классах.

 
// Хранимые свойства

// Хранимое свойство — это константа или переменная, объявленная в объектном типе и хранящая определенное значение.

// Хранимое свойство может:

// получить значение в инициализаторе (метод с именем init);
// получить значение по умолчанию в случае, если при создании экземпляра ему не передается никакое значение;
// изменить значение в процессе использования экземпляра.

// Мы уже многократно создавали хранимые свойства ранее, например, при реализации класса Chessman.



// Ленивые хранимые свойства

// Хранимые свойства могут быть «ленивыми». Значение, которое должно храниться в ленивом свойстве, не создается до момента первого обращения к нему.

// Перед операторами var и let добавляется ключевое слово lazy, указывающее на «ленивость» свойства.



class Person {
    
    var firstName = "Имя"
    var secondName = "Фамилия"
    
    lazy var wholeName: String = generateWholeName()
    
    init(name: String, secondName: String) {
        self.firstName = name
        self.secondName = secondName
    }
    
    func generateWholeName() -> String {
        firstName + " " + secondName
    }
}

var me = Person(name: "Leonid", secondName: "Nazarov")
 
// как только мы обращаеся к ленивому свойству wholeName то происходит вызов функции
me.wholeName
me.generateWholeName()

// Ленивые свойства позволяют экономить оперативную память и не расходовать ее до тех пор, пока не потребуется значение какого-либо свойства.

// в качестве значений для хранимых свойств нельзя указывать свойства и методы того же объектного типа.
// Ленивые свойства не имеют этого ограничения, так как их значения формируются уже после создания экземпляров.

// Ленивые свойства являются lazy-by-need, то есть вычисляются однажды и больше не меняют свое значение.

me.wholeName
me.secondName

me.secondName = "Safronov"
me.wholeName

// Несмотря на то что значение свойства secondName было изменено, значение ленивого свойства wholeName осталось прежним.

// создать ленивое хранимое свойство функционального типа, содержащее в себе замыкание

class People {
    var firstName = "firstName"
    var secondName = "secondName"
    
    lazy var wholeName: () -> String = {// self, потому что замыкание
        "\(self.firstName) \(self.secondName)"
    }
    
    init(name: String, secondName: String) {
        self.firstName = name
        self.secondName = secondName
    }
    
}
var otherMan = People(name: "Andrey", secondName: "Nazarov")

otherMan.secondName
otherMan.firstName

// Обратите внимание, что так как свойство хранит в себе замыкание, доступ к нему необходимо организовать с использованием скобок.

// При этом свойство wholeName, хранящее в себе замыкание, будет возвращать актуальное значение каждый раз при обращении к нему. То есть данное ленивое хранимое свойство называется lazy-by-name.

otherMan.wholeName()

otherMan.secondName = "Safronov"
otherMan.wholeName()

*/

// Почему необходимо использовать lazy для свойства wholeName? Обратите внимание, что при получении значения свойства wholeName происходит обращение к элементам этого же объектного типа (с помощью ключевого слова self). Такой подход доступен только для ленивых хранимых свойств: если убрать lazy, то Xcode сообщит об ошибке:
// error: Cannot find 'self' in scope

// В данном случае использование self является обязательным, так как происходит захват ссылки на объект (при необходимости об этом вам сообщит сам Xcode).



// Вычисляемые свойства

// Также существует иной способ создать параметр, значение которого будет вычисляться при каждом доступе к нему.

// Для этого можно использовать уже знакомые нам по перечислениям вычисляемые свойства.

// По сути, это те же ленивые хранимые свойства, имеющие функциональный тип, но определяемые в упрощенном синтаксисе.

// Вычисляемые свойства фактически не хранят значение, а вычисляют его с помощью замыкающего выражения при каждом обращении к ним.
/*
 
СИНТАКСИС
   var имяСвойства: ТипДанных {
 тело_замыкающего_выражения
 
 }
 
*/

// Вычисляемые свойства могут храниться исключительно в переменных (var). После указания имени объявляемого свойства и типа возвращаемого замыкающим выражением значения без оператора присваивания указывается замыкание, в результате которого должно быть сгенерировано возвращаемое свойством значение.

// Для того чтобы свойство возвращало некоторое значение, в теле замыкания должен присутствовать оператор return.

// Сделаем свойство wholeName класса Person вычисляемым.

class Person {
    
    var firstName = "Name"
    var secondName = "SeconName"
    
    var wholeName: String {
        return "\(self.firstName) \(self.secondName)"
    }
    
    init(name: String, secondName: String) {
        self.firstName = name
        self.secondName = secondName
    }
}

var otherMan = Person(name: "Oleg", secondName: "Nikolaevich")

otherMan.wholeName
otherMan.secondName = "Petrovich"

otherMan.wholeName

// Теперь доступ к значению свойства wholeName производится так же, как и к обыкновенным свойствам (без использования скобок), но при этом всегда возвращается актуальное значение



// Контроль значений свойств
// Геттер и сеттер вычисляемого свойства
